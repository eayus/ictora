apply : (Int -> Int) -> Int -> Int
apply f x = f x

add : Int -> Int -> Int
add x y = x + y

sum : Int -> Int -> Int
sum x y z = x + y + z

double : Int -> Int
double x = x + x

main : Int
main = apply (add 2) 3

main2 : Int
main2 = apply double 3

main3 : Int
main3 = apply (apply double) 3

main4 : Int
main4 = apply (apply (sum 1) 2) 3

main4' : Int
main4' = apply_for_main4 apply sum 1 2 3

main5 : Int -> Int
main5 = add 3


-------------------------------------
apply's 'f' (Int -> Int) has unknown structure!

so look at every use of "apply" and check all used structures

in main, f has: (Int -> Int -> Int) partially applied to Int
in main2, f is: (Int -> Int)

generate a separate apply for each usage

---------------------------------------


apply_for_main : ((Int -> Int -> Int), Int) -> Int -> Int
apply_for_main (f, arg1) x = f arg1 x

apply_for_main2 : (Int -> Int) -> Int -> Int
apply_for_main2 f x = f x

apply_for_main3 : ((Int -> Int) -> Int -> Int, Int -> Int) -> Int -> Int
apply_for_main3 (f, arg1) x = f arg1 x

apply_for_main4 : ((Int -> Int) -> Int -> Int,
                   Int -> Int -> Int,
                   Int
                   Int) -> Int
apply_for_main4 (f, g, x, y) = f (g x) y

---------------------------------------

gets a little weird with polymorphism but without it requires a heap






-----

how to deal with partially applied funtions at the top level of a function (main 5)? inline them?
perhaps we can boil the partial application problem and this down to a common problem to solve.


perhaps:

augment main5:


main5' : Int -> (Int -> Int, Int)


then, replace every usage of

main5 y
with
(let (f, x) = main5' in f x y)




--------------------------------------------------

Parse
-- Ictora
Remove Sugar
Lambda Lift
Remove Partial App
-- Core
Make Procedural 
-- AMC
Code Generation

