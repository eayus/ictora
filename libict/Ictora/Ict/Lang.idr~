module Ictora.Ict.Lang

import public Data.Vect
import public Data.Fin
import public Ictora.Util
import public Ictora.Ict.Types
import public Ictora.Misc

%access public export
%default total

record IName where
    constructor MkIName
    path : List String
    name : String


differentPath : Not (path1 = path2) -> Not (MkIName path1 name1 = MkIName path2 name2)
differentPath pathneq = \Refl => pathneq Refl


implementation DecEq IName where
    decEq (MkIName path1 name1) (MkIName path2 name2)
        = case decEq path1 path2 of
               Yes Refl => case decEq name1 name2 of
                                  Yes Refl => Yes Refl
                                  No nameneq => No $ \Refl => nameneq Refl
               No pathneq => No $ differentPath pathneq


VarName : String -> IName
VarName = MkIName []


IScope : Type
IScope = Map IName ITy


IGlobalScope : Type
IGlobalScope = (scope : IScope ** UniqKeys scope)


IModuleScope : Type
IModuleScope = Map IName IGlobalScope


emptyGlobals : IGlobalScope
emptyGlobals = ([] ** UniqNil)


mergeGlobals : IGlobalScope -> IGlobalScope -> IGlobalScope
mergeGlobals ([] ** _) ys = ys
mergeGlobals ((k, v) :: xs ** UniqCons xsNok xsUniq) (ys ** ysUniq) =
    let (zs ** zsUniq) = assert_total $ mergeGlobals (xs ** xsUniq) (ys ** ysUniq)
    in case decHasKey k zs of
            Right zsHasK => (deleteEntry zs zsHasK ** deleteRetainsUniq zsUniq)
            Left zsNoK => ((k, v) :: zs ** UniqCons zsNoK zsUniq)


data IExpr : IScope -> ITy -> Type where
    ILit : Int -> IExpr scope ITInt
    IVar : Lookup vname scope ty -> IExpr scope ty
    IApp : IExpr scope (a ~> b) -> IExpr scope a -> IExpr scope b
    ILam : (vname : String)
        -> (a : ITy)
        -> IExpr ((VarName vname, a) :: scope) b
        -> IExpr scope (a ~> b)
    ILet : (vname : String)
        -> (a : ITy)
        -> IExpr scope a
        -> IExpr ((VarName vname, a) :: scope) b -> IExpr scope b


selfIsDifferent : (MkIName [] s = MkIName ["Self"] s) -> Void
selfIsDifferent Refl impossible


data IModule : IModuleScope -> IGlobalScope -> Type where
    IEmptyModule : IModule modules scope
    IConsImport : (mname : IName)
               -> MapsOnly modules mname exports
               -> IModule modules (mergeGlobals scope exports)
               -> IModule modules scope
    IConsFunc : {funcTy : ITy}
             -> (funcName : String)
             -> let funcIName = MkIName [] funcName
             in (funcBody : IExpr scope funcTy)
             -> (inameUniq : NoKey funcIName scope)
             -> IModule modules ((funcIName, funcTy) :: scope
                                ** UniqCons inameUniq  scopeUniq)
             -> IModule modules (scope ** scopeUniq)


exposedScope : IModule modules scope -> IGlobalScope
exposedScope IEmptyModule = ?exposedScope_rhs_1
exposedScope (IConsImport mname x y) = ?exposedScope_rhs_2

{--

data IProg : IModuleScope -> Type where
    IEmptyProg : IProg []
    IConsModule : (mname : IName)
               -> (mdl : IModule modules [])
               -> IProg ((mname, exposedScope mdl) :: modules)
               -> IProg modules--}--}
