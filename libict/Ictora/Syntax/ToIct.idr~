module Ictora.Syntax.ToIct

import Ictora.Syntax.Lang
import Ictora.Syntax.TypeError
import Ictora.Ict.Lang
import Ictora.Misc
import Control.Monad.Reader
import Control.Monad.Trans

%default total


Scope : Type
Scope = Map String ITy


convertTy : STy -> Either TypeError ITy
convertTy (NamedTy "Int") = pure ITInt
convertTy (NamedTy "Float") = pure ITFloat
convertTy (NamedTy badName) = Left $ UnknownType badName []
convertTy (t ~> u) = [| convertTy t ~> convertTy u |]


convertExpr : (scope : Scope) -> SExpr -> Either TypeError (t : _ ** IExpr scope t)
convertExpr scope (SVar name) = case lookupPrf name scope of
                                     Just (t ** prf) => Right (t ** IVar prf)
                                     Nothing => Left $ UndefinedVariable name (fst <$> scope)
convertExpr scope (SApp x y) = do
    (lTy ** l) <- convertExpr scope x
    (rTy ** r) <- convertExpr scope y
    case lTy of
         (t1 ~> t2) => case decEq t1 rTy of
                            Yes Refl => pure (t2 ** IApp l r)
                            No _ => Left $ ArgTypeMismatch t1 rTy
         _ => Left $ NonFunctionApplication lTy rTy
convertExpr scope (SLam var ty x) = do
    argTy <- convertTy ty
    (bodyTy ** body) <- convertExpr ((var, argTy) :: scope) x
    pure (argTy ~> bodyTy ** ILam var argTy body)
convertExpr scope (SLet var e1 e2) = do
    (e1Ty ** e1') <- convertExpr scope e1
    (e2Ty ** e2') <- convertExpr ((var, e1Ty) :: scope) e2
    pure (e2Ty ** ILet var e1' e2')
convertExpr scope (SLit x) = pure (ITInt ** ILit x)


convertProg' : (scope : Scope) -> (uniq : UniqKeys scope) -> SProgram -> Either TypeError (IProg (scope ** uniq))
convertProg' scope uniq [] = pure Nil
convertProg' [] UniqNil (x :: xs) = ?h_1
convertProg' ((k, b) :: ys) (UniqCons y z) (x :: xs) = ?h_2















{--TypeAliases : Type
TypeAliases = List (SIdent, ITy)

Scope : Nat -> Type
Scope n = Vect n (SIdent, ITy)



defaultTAs : TypeAliases
defaultTAs = [ ("Int", ITInt), ("Float", ITFloat) ]


convertTy : TypeAliases -> STy -> Either TypeError ITy
convertTy tas (t ~> u) = [| convertTy tas t ~> convertTy tas u |]
convertTy tas (NamedTy name) = case lookup name tas of
                                    Just ity => pure ity
                                    Nothing => Left $ UnknownType name (fst <$> tas)


convertExpr : TypeAliases
           -> (scope : Scope n)
           -> SExpr
           -> Either TypeError (ty : ITy ** IExpr (snds scope) ty)
convertExpr tas scope (SVar name) = case lookupPrf name scope of
                                         Just (ty ** prf) => let (i ** loc) = keyLocation prf
                                                             in Right (ty ** IVar loc)
                                         Nothing => Left $ UndefinedVariable name $ toList $ map fst scope
convertExpr tas scope (SApp l r) = do
    (lTy ** l') <- convertExpr tas scope l
    (rTy ** r') <- convertExpr tas scope r
    case lTy of
         (t1 ~> t2) => case decEq t1 rTy of
                            Yes Refl => Right $ (t2 ** IApp l' r')
                            No _ => Left $ ArgTypeMismatch t1 rTy

         _ => Left $ NonFunctionApplication lTy rTy
convertExpr tas scope (SLam var ty x) = do
    argTy <- convertTy tas ty
    (bodyTy ** body) <- convertExpr tas ((var, argTy) :: scope) x
    Right (argTy ~> bodyTy ** ILam body)
convertExpr tas scope (SLet name e1 e2) = do
    (e1Ty ** e1') <- convertExpr tas scope e1
    (e2Ty ** e2') <- convertExpr tas ((name, e1Ty) :: scope) e2
    Right (e2Ty ** ILet e1' e2')
convertExpr tas scope (SLit x) = Right (ITInt ** ILit x)




{--convertProg : TypeAliases 
           -> (globals : Scope m)
           -> SProgram
           -> Either TypeError (IProgram globals)
convertProg _ _ [] = Right IEmptyProg
convertProg tas globals ((name, e) :: xs) = do
    (bodyT ** body) <- convertExpr tas [] globals e
    xs' <- convertProg tas ((name, bodyT) :: globals) xs
    Right $ IConsFunc name body xs'


export convert : SProgram -> Either TypeError (IProgram [])
convert = convertProg defaultTAs []--}--}
